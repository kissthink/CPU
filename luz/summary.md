# kernel的概括：

### B START 
+ 从start开始，因此先跳过第一个模块——DELINT（中断处理）


### START
+ 初始化各种东西（中断寄存器，栈地址，用户寄存器）
+ welcome，就是输出“OK”，换行，回车


### BEGIN
+ 接收字符
+ 检测是什么命令（R, D, A, U, G），然后跳转到对应的处理模块
    - R -- SHOWREGS
    - D -- SHOWMEM
    - A -- GOTOASM
    - U -- GOTOUASM
	- G -- GOTOCOMPILE
	- 具体格式和功能，请见相应模块
	- 可参见实验书P34
		

### GOTO模块（包含GOTOUASM，GOTOASM，GOTOCOMPILE）
+ 感觉它可以直接在BEGIN里实现的
+ 不过有可能是地址长度不够的缘故，因为B能跳转的距离比BTEQZ长


### TEST模块（与串口有关）
+ TESTW（检测8251是否可写）
    - 判断MEM[BF01]的最低位
	- 为1，可写
	- 为0，继续等待
+ TESTR（检测8251是否可读）
	- 判断BF01的倒数第2位
	- 为1，可读
	- 为0，等待


### 命令的处理模块
+ 发现和书上描述的差不多呃，我用口语化一点的词描述吧...

#### SHOWREGS模块
+ 格式：R
+ 功能：查看（打印出）寄存器R0-R5的值
+ 实现：
    - 用户程序寄存器R0-R5分别对应BF10-BF15
	- 6次循环
	- 每次循环 load 一个 BF1X，依次将它的低8位和高8位赋给BF00，就能让终端程序把值显示出来
	- 每次给BF00赋值前，都会调用一次TESTW，看是否可写
+ 与串口相关：
	- 输出寄存器的值
				
#### SHOWMEM模块
+ 格式：D [addr] [num]
+ 功能：查看由地址addr开始的num个内存字的值
+ 实现：
	- 接收addr
		- 先低8位，后高8位（存在R1里）
	- 接收num
		- 先低8位，后高8位（存在R2里）
	- MEMLOOP
		- 循环输出num个内存字的值
		- 和SHOWREGS完全一样，只不过是addr和num需要指定，而SHOWREGS是BF10和6
+ 与串口相关
	- 接收addr
	- 接收num
	- 输出内存字的值
				
#### ASM模块
+ 格式：A [addr]
+ 功能：修改地址addr处的值
+ 实现：
	- 只需要从串口获取addr和之后要写入的数值，再将数值写入addr即可
		- 【其中输入语句的汇编工作由Term完成，数据通过串口传递过来】
	- 具体实现：
		- 接收addr
		- 先低8位，后高8位（存在R1里）【完全同SHOWMEM】
		- 检测地址是否合法
			- 只要不为空（或0）都合法
			- 如果不合法，跳到BEGIN
		- 进入修改状态
			- 接收修改的数据
			- 保存到addr中
+ 与串口相关：
	- 接收addr
	- 接收要修改的值

#### UASM
+ 格式：U [addr] [num]
+ 功能：反汇编地址addr开始的num个内存字的值
+ 实现：
	- 同ASM，因为汇编和反汇编的工作都是在Term上完成
+ 与串口相关
	- 获取addr和num
		
#### COMPILE
+ 格式：G [addr]
+ 功能：从地址addr处开始连续执行用户程序
+ 实现：
