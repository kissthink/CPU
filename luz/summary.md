# kernel的概述：

==========================================================
## 主程序

### B START 
+ 从start开始，因此先跳过第一个模块——DELINT（中断处理）


### START
+ 初始化各种东西（中断寄存器，栈地址，用户寄存器）
+ welcome，就是输出“OK”，换行，回车
+ 与串口相关：
	- 输出上述...


### BEGIN
+ 接收字符
+ 检测是什么命令（R, D, A, U, G），然后跳转到对应的处理模块
    - R -- SHOWREGS
    - D -- SHOWMEM
    - A -- GOTOASM
    - U -- GOTOUASM
	- G -- GOTOCOMPILE
	- 具体格式和功能，请见相应模块
	- 可参见实验书P34
+ 与串口相关：
	- 接收命令字符
		
==========================================================
## 下面都是函数


### GOTO模块（包含GOTOUASM，GOTOASM，GOTOCOMPILE）
+ 可能是地址长度不够的缘故，因为B能跳转的距离比BTEQZ长
+ SHOWREGS、SHOWMEM都是在BEGIN里直接用BTEQZ直接跳转，不需要该模块中转


### TEST模块（与串口有关）
+ 在与串口交互前，都要进行检测
+ TESTW（检测8251是否可写）
    - 判断MEM[BF01]的最低位
	- 为1，可写
	- 为0，继续等待
+ TESTR（检测8251是否可读）
	- 判断BF01的倒数第2位
	- 为1，可读
	- 为0，等待


### 命令的处理模块
+ 发现和书上描述的差不多呃，我用口语化一点的词描述吧...


#### SHOWREGS模块
+ 格式：R
+ 功能：查看（打印出）用户程序寄存器R0-R5的值
+ 实现：
	- LOOP
		- 用户程序寄存器R0-R5分别对应BF10-BF15
		- 每次循环 load 一个 BF1X，依次将它的低8位和高8位赋给BF00，就能让终端程序把值显示出来
		- 每次给BF00赋值前，都会调用一次TESTW，看是否可写
+ 与串口相关：
	- 输出寄存器的值

	
#### SHOWMEM模块
+ 格式：D [addr] [num]
+ 功能：查看由地址addr开始的num个内存字的值
+ 实现：
	- 接收addr
		- 先低8位，后高8位（存在R1里）
	- 接收num
		- 先低8位，后高8位（存在R2里）
	- MEMLOOP
		- 循环输出num个内存字的值
		- 和SHOWREGS完全一样，只不过是addr和num需要指定，而SHOWREGS是BF10和6
+ 与串口相关
	- 接收addr
	- 接收num
	- 输出内存字的值

	
#### ASM模块
+ 格式：A [addr]
+ 功能：修改地址addr处的值
+ 实现：
	- 只需要从串口获取addr和之后要写入的数值，再将数值写入addr即可
		- 【其中输入语句的汇编工作由Term完成，数据通过串口传递过来】
	- 具体实现：
		- 接收addr
		- 先低8位，后高8位（存在R1里）【完全同SHOWMEM】
		- 检测地址是否合法
			- 只要不为空（或0）都合法
			- 如果不合法，跳到BEGIN
		- 进入修改状态
			- 接收修改的数据
			- 保存到addr中
+ 与串口相关：
	- 接收addr
	- 接收要修改的值

	
#### UASM模块
+ 格式：U [addr] [num]
+ 功能：反汇编地址addr开始的num个内存字的值
+ 实现：
	- 类似D [addr] [num]，因为反汇编工作不是kernel做
	- 从内存中取出值，通过串口发给Term，由Term进行反汇编处理输出
+ 与串口相关
	- 获取addr和num
	- 输出内存字的值

	
#### COMPILE模块
+ 格式：G [addr]
+ 功能：从地址addr处开始连续执行用户程序【可参见实验书P35的流程图】
	- 简单地理解，完成监控程序与用户程序间的调用转换
+ 实现：
	- 监控程序 -> 用户程序
		- 恢复寄存器（R0-R5）
		- 开启中断（把中断寄存器IH的高位置1）【只有在执行用户程序时支持中断，在监控程序时不支持，所以要执行用户程序前，需要先开启中断】
		- JR R6就是调用用户程序了
		- 用户程序执行结束，JR R7回到监控程序
		- 保存寄存器（R0-R5)
		- 关闭中断（把中断寄存器IH的高位置0）【顺序与流程图不一样，私以为应该按流程图来，不过程序就是这么写的，应该没太大影响】
		- 提示执行结束
	- 用户程序 -> 监控程序
		- 返回
			- JR R7
+ 串口相关：
	- 接收地址
	- 结束时，输出0x0007（BEL，响铃），提示执行结束
			
==================================================================================
### 中断处理


#### DELINT模块
+ 功能：支持用户程序中断
+ 实现：
	- 保存中断现场（寄存器R0-R3）
	- 输出中断号（中断服务程序的功能）
	- 恢复现场
	- 细节：
		- 也需要开启、关闭中断
		- 向BF00发送0x000F（shift)，提示Term中断处理开始 或者 中断处理结束
+ 串口相关：
	- 输出中断号
	- 输出0x000F（shift)，提示Term中断处理开始、结束


